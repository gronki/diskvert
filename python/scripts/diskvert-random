# coding: utf-8

def random_radius(r1=3.2255, r2=12.120):
    """randomizes a radius in accretion disk between r1 and r2
    with probability proportional to emitted flux from each annulus"""
    from numpy import sqrt
    from numpy.random import uniform
    from scipy.optimize import bisect

    r0 = 3.0
    yf =  lambda r: 3 * r0 * (1 - sqrt(r0 / r)) / r**2
    yfi = lambda x: 3 * r0 * (2*sqrt(r0)/(3*x**(3/2)) - 1/x) + 1
    rmax = 25 / 16 * r0

    # r1=3.0071, r2=78.256 # y0=0.01443, 90.000%
    # r1=3.0890, r2=20.080 # y0=0.16715, 66.667%
    # r1=3.2255, r2=12.120 # y0=0.37583, 50.000%
    # r1=3.4709, r2=8.2464 # y0=0.64113, 33.333%
    # r1=4.1681, r2=5.4062 # y0=0.95880, 10.000%

    t = uniform(yfi(r1), yfi(r2))

    return bisect(lambda r: yfi(r) - t, r1, r2)


def random_diskvert_model(qmin=0.1, qmax=18.0, p=0.33, dispers=0.18, 
        mbh=None, mdot=None, radius=None):

    """generates a random model to be used with diskvert program and returns a tuple
    (mbh, mdot, radius, alpha, eta, nu)"""

    from random import uniform, gauss, choice
    from math import log10, exp

    mbh_agn = lambda: 10**gauss(7.83, 0.65)
    mbh_bhb = lambda: 10**gauss(1.1, 0.15)

    if mbh is None:
        mbh = choice([mbh_agn(), mbh_bhb()])
    elif mbh.lower() in ['agn', 'smbh']:
        mbh = mbh_agn()
    elif mbh.lower() in ['bhb', 'xrb', 'bxb']:
        mbh = mbh_bhb()
    
    if mdot is None: 
        # mdot = 10**uniform(-2.5, 0.5)
        mdot = 10**gauss(-0.5, 1.0)

    if radius is None: 
        radius = random_radius()

    q, alpha, eta, xi, nu, etaxi = 0, 0, 0, 0, 0, 0

    d = dispers

    while q < qmin or q > qmax:

        etaxi = 0.3 * 10**gauss(0, d)
        alpha = 2 * etaxi / 10**uniform(0, 3)
        eta = 10**gauss(0, d) * etaxi * (alpha / (2 * etaxi))**(p * 10**gauss(0, d))
        nu = 2 * max(0, etaxi - eta) / alpha * 10**gauss(0, d)
        q = (2 * eta + alpha * (nu - 1)) / eta

    return mbh, mdot, radius, alpha, eta, nu


def random_diskvert_model_sample(N = 1024, **kwargs):

    """generates a numpy array containing a sample of random parameters to be run with diskvert"""

    from numpy import ndarray
    d = ndarray(N, dtype=[('mbh', 'f4'), ('mdot', 'f4'), ('radius', 'f4'), 
      ('alpha', 'f4'), ('eta', 'f4'), ('nu', 'f4'), ('q', 'f4'), ('beta_0', 'f4'), 
      ('etaxi', 'f4'), ('xi', 'f4'), ])

    for i in range(N):
        d['mbh'][i], d['mdot'][i], d['radius'][i], d['alpha'][i], d['eta'][i], d['nu'][i] \
          = random_diskvert_model(**kwargs)
    d['xi'] = d['alpha'] * d['nu'] / 2
    d['etaxi'] = d['eta'] + d['xi']
    A = 2 * d['etaxi'] - d['alpha']
    d['q'     ] = A / d['eta']
    d['beta_0'] = A / d['alpha']
    return d

def float_if_can(s):
    try:
        return float(s)
    except: return s

if __name__ == '__main__':

    """generate a model for diskvert and write to standard output"""

    from argparse import ArgumentParser

    parser = ArgumentParser('diskvert-random')
    parser.add_argument('-qmin', action='store', default='0.5')
    parser.add_argument('-qmax', action='store', default='20.0')
    parser.add_argument('-mbh', action='store')
    parser.add_argument('-mdot', action='store')
    parser.add_argument('-radius', action='store')
    args = parser.parse_args()
    
    f  = "  {:10s} {:.5g}"
    
    mbh, mdot, radius, alpha, eta, nu = random_diskvert_model(
        qmin=float(args.qmin), qmax=float(args.qmax), 
        mbh=float_if_can(args.mbh), mdot=float_if_can(args.mdot), radius=float_if_can(args.radius))

    print('# general parameters')
    print(f.format('mbh', mbh))
    print(f.format('mdot', mdot))
    print(f.format('radius', radius))

    print('\n# model parameters')
    print(f.format('alpha', alpha))
    print(f.format('eta', eta))
    print(f.format('nu', nu))

    xi = alpha * nu / 2
    etaxi = eta + xi
    q      = (2 * etaxi - alpha) / eta
    beta_0 = (2 * etaxi - alpha) / alpha
    
    print('# qcor = {:.3g}, beta0 = {:.3g}'.format(q, beta_0))
    print('# xi = {:.3g}, eta+xi = {:.3g}'.format(xi, etaxi))