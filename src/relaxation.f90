module relaxation

  use iso_fortran_env, only: r64 => real64, uerr => error_unit
  use ieee_arithmetic, only: ieee_is_normal

  use slf_cgs
  use globals
  use slf_ramps

  implicit none

  interface
    pure subroutine funout_t(z, Y, YY)
      import r64
      real(r64), intent(in) :: z
      real(r64), intent(in), dimension(:) :: Y
      real(r64), intent(out), dimension(:) :: YY
    end subroutine
    pure subroutine fun0_t(z, Y, F, A, M)
      import r64
      real(r64), intent(in) :: z
      real(r64), intent(in), dimension(:) :: Y
      real(r64), intent(in), dimension(:,:) :: F
      real(r64), intent(out), dimension(:) :: A
      real(r64), intent(out), dimension(:,:) :: M
    end subroutine
    pure subroutine fun1_t(z, Y, D, F, A, MY, MD)
      import r64
      real(r64), intent(in) :: z
      real(r64), intent(in), dimension(:) :: Y,D
      real(r64), intent(in), dimension(:,:) :: F
      real(r64), intent(out), dimension(:) :: A
      real(r64), intent(out), dimension(:,:) :: MY,MD
    end subroutine
    pure subroutine fun2_t(z, Y, D, D2, F, A, MY, MD, MD2)
      import r64
      real(r64), intent(in) :: z
      real(r64), intent(in), dimension(:) :: Y,D,D2
      real(r64), intent(in), dimension(:,:) :: F
      real(r64), intent(out), dimension(:) :: A
      real(r64), intent(out), dimension(:,:) :: MY,MD,MD2
    end subroutine
  end interface

  real(r64) :: alpha = 0.22, eta = 0.23, nu = 0.9
  real(r64) :: omega, radius, facc, teff, zscale
  real(r64) :: qmri_kill = 1.0, zbreak = 0., threshpow = 4.0, condux = 1.0, hydrox = 1.0

  logical :: use_quench_mri = .true.
  logical :: use_prad_in_alpha = .true.
  logical :: use_flux_correction = .true.

  
  ! important: this order must be the same as ordering of
  ! list yout in coefficients.py
  integer, parameter :: c_rho = 1, c_temp = 2, c_trad = 3, &
  c_pgas = 4, c_prad = 5, c_pmag = 6, &
  c_frad = 7, c_fmag = 8, c_fcnd = 9, &
  c_ptot_gen = 10, c_heat = 11, c_heatm = 12, c_heatr = 13, &
  c_vrise = 14, c_qmri = 15
  ! important: update this number if you add any new fields above
  integer, parameter :: N_RELAX_OUTPUTS = 15
  
  ! important: this order must be the same as ordering of
  ! list yvar_all in coefficients.py
  integer, parameter :: cc_rho = 1, cc_temp = 2, cc_trad = 3, &
  &   cc_frad = 4, cc_pmag = 5, cc_fcnd = 6
  ! important: update this number if you add any new fields above
  integer, parameter :: N_RELAX_VARS_MAX = 6

contains

  !----------------------------------------------------------------------------!
  ! Generate model number based on its properties.

  pure function mrx_number(bil, magnetic, conduction, mass_flux) result(nr)
    logical, intent(in) :: magnetic,conduction, mass_flux
    character, intent(in) :: bil
    integer :: nr

    nr = 1

    select case (bil)
    case (EQUATION_DIFFUSION)
    case (EQUATION_COMPTON)
      nr = nr + 1
    case (EQUATION_BALANCE)
      nr = nr + 3
    case default
      error stop "wrong character for bil, allowed: D,W,C"
    end select

    if (magnetic)   nr = nr + 4
    if (conduction) nr = nr + 8
    if (mass_flux) nr = nr + 16

  end function

  !----------------------------------------------------------------------------!
  ! This function returns the number of: equations, boundary conditions etc..
  ! based on the code generated by sympy.

  elemental subroutine mrx_sel_dims (nr, ny, neq0, neq1, nbl, nbr)
    integer, intent(in) :: nr
    integer, intent(out) :: ny, neq1, nbl, nbr, neq0
    include 'mrxdims.fi'
  end subroutine

  !----------------------------------------------------------------------------!
  ! A wrapper to obtain only number of variables.

  elemental subroutine mrx_sel_nvar (nr, ny)
    integer, intent(in) :: nr
    integer, intent(out) :: ny
    integer :: neq1, nbl, nbr, neq0
    call mrx_sel_dims (nr, ny, neq0, neq1, nbl, nbr)
  end subroutine

  !----------------------------------------------------------------------------!
  ! Select the pointers to generated procedures that calculate the coefficients.

  subroutine mrx_sel_funcs (nr, feq0, feq1, fbl, fbr, fout)
    integer, intent(in) :: nr
    procedure(fun1_t), pointer, intent(out) :: feq1
    procedure(funout_t), pointer, intent(out) :: fout
    procedure(fun0_t), pointer, intent(out) :: fbl, fbr, feq0
    include 'mrxptrs.fi'
  end subroutine

  !----------------------------------------------------------------------------!
  ! Generate the column hash -- the point is that the column order in the model
  ! may change. Here in IHASH we have the column number of the respective field
  ! or zero if the given model does not contain it.
  ! order: (rho, T_gas, T_rad, F_rad, P_mag, F_cond)
  ! see variable yvar_all in coefficients.py

  pure subroutine mrx_sel_hash (nr, ihash)
    integer, intent(in) :: nr
    integer, dimension(:), intent(out) :: ihash
    include 'mrxhash.fi'
  end subroutine

  !----------------------------------------------------------------------------!
  ! Procedure to select the output function. In order to constistently evaluate
  ! some values (such as heating) and avoid errors, we also obtain them from
  ! code generated from symbolic computation.

  pure subroutine mrx_sel_fout (nr, fout)
    integer, intent(in) :: nr
    procedure(funout_t), pointer, intent(out) :: fout
    include 'mrxfout.fi'
  end subroutine

  !----------------------------------------------------------------------------!
  ! Generates the linear equation system that results in corrections to the
  ! vertical structure.

  subroutine mrx_matrix(nr,x,Y,M,A)

    integer :: nr
    real(r64), dimension(:), intent(in) :: x
    ! order: [ Y1(1) Y2(1) Y3(1) Y1(2) Y2(2) Y3(2) ... ]
    real(r64), dimension(:), intent(in) :: Y
    ! order: [ A1(1) A2(1) A3(1) A1(2) A2(2) A3(2) ... ]
    real(r64), dimension(:), intent(out) :: A
    real(r64), dimension(:,:), target, intent(out) :: M

    real(r64), dimension(:,:), allocatable :: MY, MD
    real(r64), dimension(:), allocatable :: YM,DY
    integer :: i, nx,nbl,nbr,ny,neq1,neq0
    procedure(fun1_t), pointer :: feq1
    procedure(fun0_t), pointer :: fbl, fbr, feq0
    procedure(funout_t), pointer :: fout
    ! opacities array: (derivative,type)
    ! order of types: abs, sct, cond
    real(r64), dimension(3,4) :: FV
    integer, dimension(N_RELAX_VARS_MAX) :: c_

    nx = size(x)
    ! select the number of equations and determine size of the matrix
    call mrx_sel_dims(nr,ny,neq0,neq1,nbl,nbr)
    allocate( ym(ny), dy(ny), MY(neq1,ny), MD(neq1,ny) )

    ! select the functions that will compute my coefficients
    call mrx_sel_funcs(nr,feq0,feq1,fbl,fbr,fout)
    ! get the indexing for output variables
    call mrx_sel_hash(nr,c_)

    ! left (equatorial plane boundary)
    if (nbl > 0) then
      associate (xbl => x(1), YBL => Y(1:ny),     &
              &  BL  => A(1:nbl),                 &
              &  MBL => M(1:nbl,1:ny))

        ! partial derivatives of opacities
        call kappabs(YBL(c_(cc_rho)), YBL(c_(cc_temp)), FV(1,1), FV(2,1), FV(3,1))
        call kappabp(YBL(c_(cc_rho)), YBL(c_(cc_temp)), FV(1,2), FV(2,2), FV(3,2))
        call kappesp(YBL(c_(cc_rho)), YBL(c_(cc_temp)), FV(1,3), FV(2,3), FV(3,3))
        call kappcnd(YBL(c_(cc_rho)), YBL(c_(cc_temp)), FV(1,4), FV(2,4), FV(3,4))

        ! compute left boundary matrix coefficeiens
        call FBL(xbl, YBL, FV, BL, MBL)

      end associate
    end if

    ! analogically but for right (surface) boundary conditsion
    if ( nbr > 0 ) then
      associate ( xbr => x(nx), YBR => Y((nx-1)*ny+1:nx*ny), &
                & BR  => A(nbl+(nx-1)*ny+1+neq0:nx*ny),           &
                & MBR => M(nbl+(nx-1)*ny+1+neq0:nx*ny, (nx-1)*ny+1:nx*ny))

        call kappabs(YBR(c_(cc_rho)), YBR(c_(cc_temp)), FV(1,1), FV(2,1), FV(3,1))
        call kappabp(YBR(c_(cc_rho)), YBR(c_(cc_temp)), FV(1,2), FV(2,2), FV(3,2))
        call kappesp(YBR(c_(cc_rho)), YBR(c_(cc_temp)), FV(1,3), FV(2,3), FV(3,3))
        call kappcnd(YBR(c_(cc_rho)), YBR(c_(cc_temp)), FV(1,4), FV(2,4), FV(3,4))

        call FBR(xbr, YBR, FV, BR, MBR)

      end associate
    end if

    ! compute band matrix coefficients for 0-th order equations
    if ( neq0 > 0 ) then
      fillc: do i = 1,nx

        associate ( xc => x(i), YC => Y((i-1)*ny+1:i*ny),    &
                  &  C => A(nbl+(i-1)*ny+1:nbl+(i-1)*ny+neq0), &
                  & MC => M(nbl+(i-1)*ny+1:nbl+(i-1)*ny+neq0, (i-1)*ny+1:i*ny))

          call kappabs(YC(c_(cc_rho)), YC(c_(cc_temp)), FV(1,1), FV(2,1), FV(3,1))
          call kappabp(YC(c_(cc_rho)), YC(c_(cc_temp)), FV(1,2), FV(2,2), FV(3,2))
          call kappesp(YC(c_(cc_rho)), YC(c_(cc_temp)), FV(1,3), FV(2,3), FV(3,3))
          call kappcnd(YC(c_(cc_rho)), YC(c_(cc_temp)), FV(1,4), FV(2,4), FV(3,4))

          call feq0(xc, YC, FV, C, MC)

        end associate
      end do fillc
    end if

    ! compute band matrix coefficients for 1-st order equations

    filla: do i = 1, nx-1

      associate ( dx => x(i+1) - x(i), xm => (x(i+1) + x(i)) / 2, &
              &   Ai => A(nbl+(i-1)*ny+1+neq0:nbl+i*ny),                 &
              &   M1 => M(nbl+(i-1)*ny+1+neq0:nbl+i*ny, (i-1)*ny+1:i*ny),  &
              &   M2 => M(nbl+(i-1)*ny+1+neq0:nbl+i*ny, i*ny+1:(i+1)*ny),  &
              &   Y1 => Y((i-1)*ny+1:i*ny), Y2 => Y(i*ny+1:(i+1)*ny))

        YM(:) = (Y2 + Y1) / 2
        DY(:) = (Y2 - Y1) / dx

        call kappabs(YM(c_(cc_rho)), YM(c_(cc_temp)), FV(1,1), FV(2,1), FV(3,1))
        call kappabp(YM(c_(cc_rho)), YM(c_(cc_temp)), FV(1,2), FV(2,2), FV(3,2))
        call kappesp(YM(c_(cc_rho)), YM(c_(cc_temp)), FV(1,3), FV(2,3), FV(3,3))
        call kappcnd(YM(c_(cc_rho)), YM(c_(cc_temp)), FV(1,4), FV(2,4), FV(3,4))

        call feq1(xm, YM, DY, FV, Ai, MY, MD)

        M1(:,:) = MY / 2 - MD / dx
        M2(:,:) = MY / 2 + MD / dx

      end associate

    end do filla

    deallocate(MY, MD, YM, DY)

  end subroutine

  !----------------------------------------------------------------------------!
  ! Transfers vector Y between the models. Deletes columns if moving to lower
  ! model and fills them with guessed or default values if moving to more
  ! sophisticated model.

  subroutine mrx_transfer(nr_old, nr, z, Y)
    use slf_cgs, only: cgs_k_over_mh
    integer, intent(in) :: nr
    integer, intent(inout) :: nr_old
    real(r64), intent(in), dimension(:) :: z
    real(r64), intent(inout), dimension(:), allocatable, target :: Y
    real(r64), dimension(:), allocatable, target :: y_old
    real(r64), dimension(:,:), pointer :: yv, yv_old
    ! column order: rho, Tgas, Trad, Frad, Pmag, Fcond
    integer, dimension(N_RELAX_VARS_MAX) :: c_, c_old_
    integer :: ny, ny_old

    call mrx_sel_hash(nr_old, c_old_)
    call mrx_sel_nvar(nr_old, ny_old)

    call mrx_sel_hash(nr, c_)
    call mrx_sel_nvar(nr, ny)

    call move_alloc(y, y_old)
    allocate(y(size(z)*ny))

    yv(1:ny,1:size(z)) => y
    yv_old(1:ny_old,1:size(z)) => y_old

    ! density, temperature and radiative flux are present in all models
    yv(c_(cc_rho),:) = yv_old(c_old_(cc_rho),:)
    yv(c_(cc_temp),:) = yv_old(c_old_(cc_temp),:)
    yv(c_(cc_frad),:) = yv_old(c_old_(cc_frad),:)

    ! if radiative and gas temperature are different in the new model,
    ! then set it equal to "diffusive" temperature
    if ( c_(cc_temp) .ne. c_(cc_trad) ) then
      yv(c_(cc_trad),:) = yv_old(c_old_(cc_trad),:)
    end if

    ! transfer magnetic pressure if present in new model
    if ( c_(cc_pmag) .ne. 0 ) then
      ! if the old model also had it, just copy
      if ( c_old_(cc_pmag) .ne. 0 ) then
        yv(c_(cc_pmag),:) = yv_old(c_old_(cc_pmag),:)
      else
        ! if not, set magnetic beta to constant value of 100
        yv(c_(5),:) = 0.1 * 2 * cgs_k_over_mh * yv(c_(cc_rho),:) * yv(c_(cc_temp),:)
      end if
    end if

    ! transfer thermal conduction flux if present in new model
    if ( c_(cc_fcnd) .ne. 0 ) then
      ! if the old model also had it, just copy
      if ( c_old_(cc_fcnd) .ne. 0 ) then
        yv(c_(cc_fcnd),:) = yv_old(c_old_(cc_fcnd),:)
      else
        ! if not, just set to zero
        yv(c_(cc_fcnd),:) = 0
      end if
    end if

    ! IMPORTANT
    ! if you ever add models with more variables, make sure to implement here
    ! a way to initialize more complicated model from a simpler model.

    deallocate(y_old)
    nr_old = nr

  end subroutine

  !----------------------------------------------------------------------------!
  ! Allows to convert matrix to band format used by GBSV lapack procedure.

  subroutine mrx_bandim(nr, kl, ku)
    integer, intent(in) :: nr
    integer, intent(out) :: kl, ku
    integer :: ny, neq0, neq1, nbl, nbr

    call mrx_sel_dims(nr,ny,neq0,neq1,nbl,nbr)

    ku = 2 * (neq0 + neq1) - (1 + neq0 + nbl)
    kl = (neq0 + neq1) + nbl - 1
  end subroutine

  subroutine m2band(A,KL,KU,AB)
    real(r64), dimension(:,:), intent(in) :: A
    integer, intent(in) :: KL, KU
    real(r64), dimension(:,:), allocatable, intent(out) :: AB
    integer :: i,j,n

    if (size(A,1) /= size(A,2)) error stop "sizes must match!"

    n = size(A,1)

    if (allocated(AB)) then
      if ( size(AB,1) /= 2 * KL + KU + 1 .or. size(AB,2) /= N ) then
        deallocate(ab)
        allocate(AB(2 * KL + KU + 1, N))
      end if
    else
      allocate(AB(2 * KL + KU + 1, N))
    end if

    do j = 1, N
      do i = max(1, j - KU), min(N, j + KL)
        AB(KL + KU + 1 + i - j, j) = A(i, j)
      end do
    end do

  end subroutine m2band

  !----------------------------------------------------------------------------!
  ! Here all procedures generated by sympy are included.

  include 'mrxcoeff.fi'

end module relaxation

!------------------------------------------------------------------------------!
!------------------------ C BINDINGS FOR RELAXATION ---------------------------!
!------------------------------------------------------------------------------!

module relaxation_c

  use iso_c_binding
  use iso_fortran_env, only: r64 => real64
  use relaxation

  implicit none

contains

  subroutine mrx_number_c(cor, mag, cnd, mf, nr) bind(C)
    integer(c_int), intent(in), value :: mag, cnd, mf
    character(c_char), intent(in), value :: cor
    integer(c_int), intent(out) :: nr

    nr = mrx_number(cor, mag .ne. 0, cnd .ne. 0, mf .ne. 0)
  end subroutine

  !----------------------------------------------------------------------------!

  subroutine mrx_get_ny_c(nr, ny) bind(C)
    integer(c_int), intent(in), value :: nr
    integer(c_int), intent(out) :: ny
    integer :: na, nc, nbl, nbr

    call mrx_sel_dims(nr, ny, nc, na, nbl, nbr)

  end subroutine

  !----------------------------------------------------------------------------!

  subroutine mrx_init_c(mb, md, r, alph, et, n) bind(C)
    real(c_double), intent(in), value :: mb, md, r, alph, et, n
    mbh = mb
    mdot = md
    radius = r
    alpha = alph
    eta = et
    nu = n
    call cylinder(mbh, mdot, radius, rschw, omega, facc, teff, zscale)
  end subroutine

  !----------------------------------------------------------------------------!

  subroutine mrx_matrix_c(nr,X,nx,Y,ny,A,na,M) bind(C)

    integer(c_int), intent(in), value :: nx,ny,na,nr
    real(c_double), intent(in), dimension(nx) :: X
    real(c_double), intent(in), dimension(nx*ny) :: Y
    real(c_double), intent(out), dimension(nx*na) :: A
    real(c_double), intent(out), dimension(nx*na,nx*ny) :: M

    call mrx_matrix(nr,x,Y,M,A)

  end subroutine

  !----------------------------------------------------------------------------!

  subroutine mrx_advance_c(nr,X,nx,Y,dY,ny,errno) bind(C)

    integer(c_int), intent(in), value :: nx,ny,nr
    integer(c_int), intent(out) :: errno
    real(c_double), intent(in), dimension(nx) :: X
    real(c_double), intent(in), dimension(nx*ny) :: Y
    real(c_double), intent(out), dimension(nx*ny) :: dY
    integer, allocatable :: ipiv(:)
    integer :: kl, ku
    real(c_double), allocatable :: M(:,:), MB(:,:)

    allocate(M(nx*ny,nx*ny), ipiv(nx*ny))

    call mrx_matrix(nr, x, Y, M, dY)
    ! transfer standard matrix to band representation
    call mrx_bandim(nr, kl, ku)
    call m2band(M, KL, KU, MB)
    ! call LAPACK for band matrix
    call dgbsv(size(MB,2), KL, KU, 1, MB, size(MB,1), ipiv, dY, size(dY), errno)

  end subroutine

end module
